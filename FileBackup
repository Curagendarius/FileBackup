#!/bin/bash

#Функция ротации архивов (уделение устаревших архивов)
funArhRotation ()
{
	#Удаление старых ежемесячных архивов
	let "TailArg = ArhNumMonthly + 1"
	IFS=$'\n'; for NextOldMonthly in `ls -t $ArchPath$ArchTemplate"-monthly"* | tail -n +$TailArg`; 
	do
		if [ $NextOldMonthly != $ArchFullName ]; 
		then
			#Удаляем текущий архив
			`rm $NextOldMonthly`

			#Проверяем удачно ли произошло удаление старого архива
			if [ $? -eq 0 ];
			then
				#Если удаление прошло удачно, то пишем в лог о удачном удалении старого архива
				printf `(date +%Y-%m-%d-%H-%M-%S)`": Старый архив "$NextOldMonthly" успешно удален \n" >> $BackupLog
			else
				#Если удаление прошло неудачно, то ошибка
				printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА удаления старого архива: "$NextOldMonthly" \n" >> $BackupLog
				flagOKGlobal=false
			fi 
		fi
	done

	#Удаление старых еженедельных архивов
	let "TailArg = ArhNumWeekly + 1"
	IFS=$'\n'; for NextOldWeekly in `ls -t $ArchPath$ArchTemplate"-weekly"* | tail -n +$TailArg`; 
	do
		if [ $NextOldWeekly != $ArchFullName ]; 
		then
			#Удаляем текущий архив
			`rm $NextOldWeekly 2>> $BackupLog`

			#Проверяем удачно ли произошло удаление старого архива
			if [ $? -eq 0 ];
			then
				#Если удаление прошло удачно, то пишем в лог о удачном удалении старого архива
				printf `(date +%Y-%m-%d-%H-%M-%S)`": Старый архив "$NextOldWeekly" успешно удален \n" >> $BackupLog
			else
				#Если удаление прошло неудачно, то ошибка
				printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА удаления старого архива: "$NextOldWeekly" \n" >> $BackupLog
				flagOKGlobal=false
			fi 
		fi
	done

	#Удаление старых ежедневных архивов
	let "TailArg = ArhNumDaily + 1"
	IFS=$'\n'; for NextOldDaily in `ls -t $ArchPath$ArchTemplate"-daily"* | tail -n +$TailArg`; 
	do
		if [ $NextOldDaily != $ArchFullName ]; 
		then
			#Удаляем текущий архив
			`rm $NextOldDaily 2>> $BackupLog`

			#Проверяем удачно ли произошло удаление старого архива
			if [ $? -eq 0 ];
			then
				#Если удаление прошло удачно, то пишем в лог о удачном удалении старого архива
				printf `(date +%Y-%m-%d-%H-%M-%S)`": Старый архив "$NextOldDaily" успешно удален \n" >> $BackupLog
			else
				#Если удаление прошло неудачно, то ошибка
				printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА удаления старого архива: "$NextOldDaily" \n" >> $BackupLog
				flagOKGlobal=false
			fi 
		fi
	done
}

#Функция обработки каждого задания на архивацию
funArhCreation ()
{

	#Флаг успешности выполнения каждого задания на архивацию
	flagOKLocal=true

	#Если последним символом каталога назначения не является "/" то добавляем его
	if [ ${ArchPath:(-1):1} != "/" ]; 
	then
		ArchPath=$ArchPath"/"
	fi

	#Если источник недоступен для чтения, то ошибка создания архива
	if [  ! -r $SrcPath ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" Источник "$SrcPath" не доступен для чтения \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	fi

	#Если каталог назначения недоступен для записи, то ошибка содания архива
	if [  ! -w $ArchPath ] | [  ! -d $ArchPath ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" Каталог "$ArchPath" не доступен для записи или не явлется каталогом \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	fi

	#Формируем имя архива
	printf "\n" >> $BackupLog

	#Ищем имя самого последнего ежемесячного архива 
	OldEndMonthlyArh=`ls -t $ArchPath$ArchTemplate"-monthly"* | head -1`
			
	#Проверяем а есть ли вообще последний ежемесячный архив
	if [ $OldEndMonthlyArh ]; 
	then
		#Если у нового архива месяц новый и ArhNumMonthly>0 то суфикс имени архива будет monthly
		if [ ${OldEndMonthlyArh:(-24):2} != `date +%m` ] && [ $ArhNumMonthly -gt 0 ]; 
		then
			ArhSufix="monthly"
		fi
	else 
		ArhSufix="monthly"
	fi

	#Ищем имя самого последнего еженедельного архива
	OldEndWeeklyArh=`ls -t $ArchPath$ArchTemplate"-weekly"* | head -1`

	#Проверяем а есть ли вообще последний еженедельный архив
	if [ $OldEndWeeklyArh ]; 
	then
		#Если неделя изменилась, а ArсhSufix="" и ArсhNumWeekly>0 то суфикс имени архива будет weekly 
		if [ ${OldEndWeeklyArh:(-18):2} != `date +%U` ] && [ $ArhNumWeekly -gt 0 ] && [ ! $ArhSufix ]; 
		then
			ArhSufix="weekly"
		fi
	else
		if [ ! $ArhSufix ]; 
		then
			ArhSufix="weekly"
		fi
	fi

	#Если ArсhSufix="" и ArсhNumDaily>0 то суфикс имени архива будет daily
	if [ $ArhNumDaily -gt 0 ] && [ ! $ArhSufix ]; 
	then
		ArhSufix="daily"
	fi

	#Если суфикс архива не определен то ошибка задачи параметров архива
	if [ ! $ArhSufix ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" Не задано ненулевое количество архивов \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	else
		#Иначе генерируем имя нового архива 
		ArchFullName=$ArchPath$ArchTemplate"-"$ArhSufix"-"`(date +%Y-%m-%d-%U-%H_%M_%S)`".tar.gz"
	fi

	#Если файл с таким именем архива существует - то ошибка архива
	if [ -a $ArchFullName ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" Архив с таким именем уже существует - архив не создан \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	fi

	#Создаем имя временного файла архива
	TempArchFullName=$ArchPath$ArchTemplate"-temp"
	# Если временный файл существует то удалить его - если удалить не получается то ошибка
	if [ -a $TempArchFullName ] 
	then
		`rm $TempArchFullName`
		if [ $? -eq 0 ];
			then
				printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" из источника "$SrcPath" не удалось удалить временный файл архива перед его созданием \n" >> $BackupLog
				flagOKGlobal=false
			fi
	fi


	#Если ошибок подготовки архивации этого задания на архивацию не было, то начинаем архивацию
	if [ flagOKLocal ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": Начало создания архива "$ArchFullName" из источника "$SrcPath"\n" >> $BackupLog
		

		`tar -czpf $TempArchFullName $SrcPath 2>> $BackupLog`

		#Проверяем удачно ли произошло архивирование
		if [ $? -eq 0 ];
		then
			printf `(date +%Y-%m-%d-%H-%M-%S)`": Архив "$ArchFullName" успешно создан \n" >> $BackupLog

			if [ -a $ArchFullName ]; 
			then
				printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" Архив с таким именем уже существует - невозможно переименовать временный файл архива \n" >> $BackupLog
				flagOKGlobal=false	
			else
				`mv $TempArchFullName $ArchFullName`
				#Если переименовать не получилось то ошибка
				if [ -a $ArchFullName ];
				then
					printf `(date +%Y-%m-%d-%H-%M-%S)`": Временный файл архива "$ArchFullName" из источника "$SrcPath" успешно преименован\n" >> $BackupLog
				else
					printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" из источника "$SrcPath" не удалось переименовать временный файл архива \n" >> $BackupLog
					flagOKGlobal=false
				fi

			fi

			#Запускаем функцию удаления ненужных архивов (ротация архивов)
			funArhRotation

		else
			printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" из источника "$SrcPath" Процесс создания архива прошел с ошибками \n" >> $BackupLog
			flagOKGlobal=false
		fi 
	fi
}


##############################
###  ТОЧКА СТАРТА СКРИПТА  ###

#Флаг  нормального завершения всей процедуры резервного копирования
flagOKGlobal=true

#Определяем путь запуска скрипта
# current path resolver from http://stackoverflow.com/a/246128
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
INSTALL_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
SCRIPT_NAME=$INSTALL_DIR"/"$(basename "$SOURCE")

#Задаем рассположение логфайлов
BackupLog="/var/log/FileBackup.log"
ErrorLog="/var/log/FileBackupERROR.log"
FileWorkCFG=$INSTALL_DIR"/work.cfg"

#Если нет файла work.cfg то производим установку
if [ ! -a $FileWorkCFG ]
then
	#Пишем всякое для пользователя-установщика
	echo "Призводим установку скрипта "$SCRIPT_NAME


	#Создаем файл work.cfg
	echo "Создаем файл work.cfg"

	echo "# В данном списке по каждому источнику архивации заполняется следующие строки:" > $FileWorkCFG
	echo "#	1) путь к папке источника	архивации (что архивируем)" >> $FileWorkCFG
	echo "#	2) путь к папке куда будем складывать архивы" >> $FileWorkCFG
	echo "#	3) шаблон имени архива. К шаблогу будет добавлен суфикс типа (Daily, Weekly, Monthly) архива и дата арихива для получения имени архива" >> $FileWorkCFG
	echo "#	4) full или diff - если full, то делаем все архивы будут полными; если diff, то ежедневные архивы всегда диференциальные относительно последнего полного архива " >> $FileWorkCFG 		
	echo "#	5) сторка дополнительных параметров с разделителем |" >> $FileWorkCFG
	echo "#		a) количество ежедневных копий" >> $FileWorkCFG
	echo "#		c) количество еженедельных копий (необязательный параметр)" >> $FileWorkCFG
	echo "#		d) количество ежемесячных копий (необязательный параметр)" >> $FileWorkCFG
	echo "#" >> $FileWorkCFG
	echo "# Пример:" >> $FileWorkCFG
	echo "# /var/lib/plexmediaserver" >> $FileWorkCFG
	echo "# /mnt/BackUp/Plex/" >> $FileWorkCFG
	echo "# plexSettings" >> $FileWorkCFG
	echo "# full" >> $FileWorkCFG
	echo "# 40" >> $FileWorkCFG
	echo "#" >> $FileWorkCFG
	echo "# /usr/plex" >> $FileWorkCFG
	echo "# /mnt/Bаckup/Plex/" >> $FileWorkCFG
	echo "# plexProg" >> $FileWorkCFG
	echo "# full" >> $FileWorkCFG
	echo "# 4|4|6" >> $FileWorkCFG
	echo "#" >> $FileWorkCFG
	echo "# /home/user/temp" >> $FileWorkCFG
	echo "# /mnt/Backup/НomeUserTemp/" >> $FileWorkCFG
	echo "# HomeUserTemp" >> $FileWorkCFG
	echo "# diff" >> $FileWorkCFG
	echo "# 3" >> $FileWorkCFG
	echo "#" >> $FileWorkCFG
	echo "# Первое задание архивации" >> $FileWorkCFG

	#Устанавливаем права на файл work.cfg
	if [ -a $FileWorkCFG ]
	then
		`chmod 660 $FileWorkCFG`
		if [ $? -ne 0 ];
		then 
			echo "Не удается задать права на логфайл "$FileWorkCFG
			flagOKGlobal=false
		fi
	else
		echo "Не удается создать файл "$FileWorkCFG
		flagOKGlobal=false
	fi

	#Устанавливаем права на себя
	if [ -a $SCRIPT_NAME ]
	then
		`chmod 760 $SCRIPT_NAME`
		if [ $? -ne 0 ];
		then 
			echo "Не удается задать права на логфайл "$SCRIPT_NAME
			flagOKGlobal=false
		fi
	else
		echo "Нет доступа к самому себе - "$SCRIPT_NAME
		flagOKGlobal=false
	fi

	#Пишем всякое для пользователя-установщика
	if [ flagOKGlobal ]; 
	then
		echo "Для установки скрипта в cron запустите crontab -e и добавтье следующую строку для выполнения каждый день в 23.30"
		echo "30 23 * * * "$INSTALL_DIR"/FileBackup"
		echo "Задания на архивирование задайте в файле work.cfg"
	else
		echo "Во время установки скрипта возникли ошибки!!!"
	fi
fi

if [ ! -w $BackupLog ]
then
	`cat</dev/null>$BackupLog`
	if [ -a $BackupLog ] 
	then
		echo "Файл "$BackupLog" успешно создан"

		# Задаем права на чтение и редактирование для всех (664) на логфайл сессии резервного копирования
		`chmod 664 $BackupLog`
		if [ $? -ne 0 ];
		then 
			echo "Не удается задать права на логфайл "$BackupLog
			flagOKGlobal=false
		fi
	else
		echo "Не получается создать файл с именем "$BackupLog
		flagOKGlobal=false
	fi
fi

if [ ! -w $ErrorLog ]
then
	#Создание файла лога сессии резервного копирования 
	`cat</dev/null>$ErrorLog`
	if [ -a $ErrorLog ]; 
	then
		echo "Файл "$ErrorLog" успешно создан"
		# Задаем права на чтение и редактирование для всех (664) на логфайл ошибок сессии резервного копирования
		`chmod 664 $ErrorLog`
		if [ $? -ne 0 ];
		then 
			echo "Не удается задать права на логфайл "$ErrorLog
			flagOKGlobal=false
		fi
	else
		echo "Не получается создать файл с именем "$ErrorLog
		flagOKGlobal=false
	fi
fi



#Очищаем старый лог файл если он есть
cat /dev/null > $BackupLog
if [ $? -eq 0 ];
then 
	printf `(date +%Y-%m-%d-%H-%M-%S)`": Файл лога предыдущей сессии успешно удален \n" >> $BackupLog
else
	echo "Не возможно очистить лог сессии выполнения задания резервного копирования - задание остановленно !!!"
	flagOKGlobal=false
fi


if ( $flagOKGlobal );
then
	#Флаг для того чтобы в одном цикле считывать поочереди каждую строку для каждого источника архивирования
	SrcListStringIterator="0"
	
	#Очищаем файл с входными значениями заданий архитвации от комментариев и пропусков строк
	PurifiedListParam=`sed '/^\s*#/d;/^$/d;' $INSTALL_DIR/work.cfg`

	for NextListElement in $PurifiedListParam
	do
		case $SrcListStringIterator in
			"1"|"0" )
			SrcPath=$NextListElement
			SrcListStringIterator="2"
				;;

			"2" )
			ArchPath=$NextListElement
			SrcListStringIterator="3"
				;;

			"3" )
			ArchTemplate=$NextListElement
			SrcListStringIterator="4"
				;;


			"4" )
			ExtParams=$NextListElement
			SrcListStringIterator="1"

			#Разбираем строку дополнительных параетров
			ArhNumDaily=0
			ArhNumWeekly=0
			ArhNumMonthly=0
			ArhSufix=""
			ExtParamsStringIterator="0"

			
			IFS=$'|'; for NextParam in $ExtParams; 
			do
			 	case $ExtParamsStringIterator in
			 		"1"|"0" )
					ExtParamsStringIterator="2"
					ArhNumDaily=$NextParam
			 			;;
			 		"2" )
					ExtParamsStringIterator="3"
					ArhNumWeekly=$NextParam
			 			;;
			 		"3" )
					ArhNumMonthly=$NextParam
			 			;;	
			 	esac
			done 

			#Запускаем функцию создания архива для текущего задания архивации
			funArhCreation
				;;	
		esac
	done

	#Если все процессы архивирования прошли успешно, то очищаем лог ошибок. Если нет то отправляем лог текушей сессии с сообщением о ошибке по электронной почте 
	#и добавляем содержимое текущего лога в лог о ошибках
	if ( $flagOKGlobal );
	then
		echo "ВСЕ ЗАДАНИЯ АРХИВИРОВАНИЯ ВЫПОЛНЕННЫ УСПЕШНО. Подробности выполнения смотрте в логе "$BackupLog
		printf "\n" >> $BackupLog
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ВСЕ ЗАДАНИЯ АРХИВИРОВАНИЯ ВЫПОЛНЕННЫ УСПЕШНО" >> $BackupLog
		cat /dev/null > $ErrorLog
		###? сообщаем о успешном выполнении резервного копирования

		###? пишем в флаг файл дату и время последнего успешного завершения резервного копирования

	else
		echo "ПРИ ВЫПОЛНЕНИИ ЗАДАНИЙ АРХИВИРОВАНИЯ БЫЛИ ОБНАРУЖЕНЫ ОШИБКИ. Подробности выполнения смотрте в логе "$ErrorLog
		printf "\n" >> $BackupLog
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ЗАДАНИЯ АРХИВИРОВАНИЯ ВЫПОЛНЕННЫ С ОШИБКАМИ !!! \n" >> $BackupLog
		printf "____________________________________________\n" >> $ErrorLog
		cat $BackupLog >> $ErrorLog
		###? отправляем $BackupLog с сообщением о ошибке

	fi
fi	