#!/bin/bash

#Функция ротации архивов (уделение устаревших архивов)
funArhRotation ()
{
	#Удаление старых ежемесячных архивов
	let "TailArg = ArhNumMonthly + 1"
	IFS=$'\n'; for NextOldMonthly in `ls -t $ArchPath$ArchTemplate"-monthly"* | tail -n +$TailArg`; 
	do
		if [ $NextOldMonthly != $ArchFullName ]; 
		then
			#Удаляем текущий архив
			`rm -f $NextOldMonthly 2>> $BackupLog`

			#Проверяем удачно ли произошло удаление старого архива
			if [ $? -eq 0 ];
			then
				#Если удаление прошло удачно, то пишем в лог о удачном удалении старого архива
				printf `(date +%Y-%m-%d-%H-%M-%S)`": Старый архив "$NextOldMonthly" успешно удален \n" >> $BackupLog
			else
				#Если удаление прошло неудачно, то ошибка
				printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА удаления старого архива: "$NextOldMonthly" \n" >> $BackupLog
				flagOKGlobal=false
			fi 
		fi
	done

	#Удаление старых еженедельных архивов
	let "TailArg = ArhNumWeekly + 1"
	IFS=$'\n'; for NextOldWeekly in `ls -t $ArchPath$ArchTemplate"-weekly"* | tail -n +$TailArg`; 
	do
		if [ $NextOldWeekly != $ArchFullName ]; 
		then
			#Удаляем текущий архив
			`rm -f $NextOldWeekly 2>> $BackupLog`

			#Проверяем удачно ли произошло удаление старого архива
			if [ $? -eq 0 ];
			then
				#Если удаление прошло удачно, то пишем в лог о удачном удалении старого архива
				printf `(date +%Y-%m-%d-%H-%M-%S)`": Старый архив "$NextOldWeekly" успешно удален \n" >> $BackupLog
			else
				#Если удаление прошло неудачно, то ошибка
				printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА удаления старого архива: "$NextOldWeekly" \n" >> $BackupLog
				flagOKGlobal=false
			fi
		fi
	done

	#Удаление старых ежедневных архивов
	let "TailArg = ArhNumDaily + 1"
	IFS=$'\n'; for NextOldDaily in `ls -t $ArchPath$ArchTemplate"-daily"* | tail -n +$TailArg`; 
	do
		if [ $NextOldDaily != $ArchFullName ]; 
		then
			#Удаляем текущий архив
			`rm -f $NextOldDaily 2>> $BackupLog`

			#Проверяем удачно ли произошло удаление старого архива
			if [ $? -eq 0 ];
			then
				#Если удаление прошло удачно, то пишем в лог о удачном удалении старого архива
				printf `(date +%Y-%m-%d-%H-%M-%S)`": Старый архив "$NextOldDaily" успешно удален \n" >> $BackupLog
			else
				#Если удаление прошло неудачно, то ошибка
				printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА удаления старого архива: "$NextOldDaily" \n" >> $BackupLog
				flagOKGlobal=false
			fi 
		fi
	done
}

#Функция обработки каждого задания на архивацию
funArhCreation ()
{

	#Флаг успешности выполнения каждого задания на архивацию
	flagOKLocal=true

	#Флаг надо ли делать сейчас диференциальный архив
	flagFullNow=true

	#Если последним символом каталога назначения не является "/" то добавляем его
	if [ ${ArchPath:(-1):1} != "/" ]; 
	then
		ArchPath=$ArchPath"/"
	fi

	#Если источник недоступен для чтения, то ошибка создания архива
	if [  ! -r $SrcPath ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" Источник "$SrcPath" не доступен для чтения \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	fi

	#Если каталог назначения недоступен для записи, то ошибка содания архива
	if [  ! -w $ArchPath ] | [  ! -d $ArchPath ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" Каталог "$ArchPath" не доступен для записи или не явлется каталогом \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	fi

	#Формируем имя архива
	printf "\n" >> $BackupLog

	#Ищем имя самого последнего ежемесячного архива 
	OldEndMonthlyArh=`ls -t $ArchPath$ArchTemplate"-monthly"* | head -1`
			
	#Проверяем а есть ли вообще последний ежемесячный архив
	if [ $OldEndMonthlyArh ]; 
	then
		#Если у нового архива месяц новый и ArhNumMonthly>0 то суфикс имени архива будет monthly
		if [ ${OldEndMonthlyArh:(-24):2} != `date +%m` ] && [ $ArhNumMonthly -gt 0 ]; 
		then
			ArhSufix="monthly"
		fi
	else 
		ArhSufix="monthly"
	fi

	#Ищем имя самого последнего еженедельного архива
	OldEndWeeklyArh=`ls -t $ArchPath$ArchTemplate"-weekly"* | head -1`

	#Проверяем а есть ли вообще последний еженедельный архив
	if [ $OldEndWeeklyArh ]; 
	then
		#Если неделя изменилась, а ArсhSufix="" и ArсhNumWeekly>0 то суфикс имени архива будет weekly 
		if [ ${OldEndWeeklyArh:(-18):2} != `date +%U` ] && [ $ArhNumWeekly -gt 0 ] && [ ! $ArhSufix ]; 
		then
			ArhSufix="weekly"
		fi
	else
		if [ ! $ArhSufix ]; 
		then
			ArhSufix="weekly"
		fi
	fi

	#Если ArсhSufix="" и ArсhNumDaily>0 то суфикс имени архива будет daily
	if [ $ArhNumDaily -gt 0 ] && [ ! $ArhSufix ]; 
	then
		ArhSufix="daily"
		if [ $ArchType="diff" ]
		then
			flagFullNow=false
		fi
	fi

	#Ищем опорный полный архив если делаем сейчас диференциальную копию
	if [ ! $flagFullNow ]
	then
	 	#Ищем журнал поддержки диференциальных копий последнего полного архива (он имеет имя кончающееся на .diff)
	 	ArchNameDiffFull=`ls -t $ArchPath$ArchTemplate*.diff | head -n 1`
	 	if [ -a $ArchNameDiffFull ]
	 	then
	 		#Генерим суффикс для имени архива с указанием на полный архив
	 		ArhDiffSufix=`echo ${ArchNameDiffFull##*/} | sed 's/.diff//g' | rev | cut -c 1-25 | rev`
	 	else
	 		flagFullNow=true		
	 	fi
	fi 

	#Если суфикс архива не определен то ошибка задачи параметров архива
	if [ ! $ArhSufix ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" Не задано ненулевое количество архивов \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	else
		#Иначе генерируем имя нового архива 
		if [ ! $flagFullNow ] 
		then
			#Если делаем архив с поддержкой диференциальных копий и ежедневный архив то в имени надо указать ссылку на опорный полный архив
			ArchFullName=$ArchPath$ArchTemplate"-"$ArhSufix"-From-"$ArhDiffSufix"-To-"`(date +%Y-%m-%d-%U-%H_%M_%S)`".tar.gz"
		else
			#Если делаем полный архив
			ArchFullName=$ArchPath$ArchTemplate"-"$ArhSufix"-"`(date +%Y-%m-%d-%U-%H_%M_%S)`".tar.gz"
			if [ $ArchType="diff" ]
			then
				#Генерим имя журнала нового опорного полного архива
				ArchNameDiffFull=$ArchPath$ArchTemplate"-"$ArhSufix"-"`(date +%Y-%m-%d-%U-%H_%M_%S)`".diff"
			fi
		fi
	fi

	#Если файл с таким именем архива существует - то ошибка архива
	if [ -a $ArchFullName ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" Архив с таким именем уже существует - архив не создан \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	fi

	#Создаем имя временного файла архива
	TempArchFullName=$ArchPath$ArchTemplate"-temp"
	# Если временный файл существует то проверяем не истекло ли предельное время выполнения архива
	if [ -a $TempArchFullName ] 
	then
		#В любом случае пропускаем это задание
		flagOKLocal=false
		
		#Если предельное время исполнения архива прошло, то сообщаем о глобальной ошибке
		###?
			flagOKGlobal=false
	else

		#Если надо то создаем имя файла журнала диференциального архива
		if [ $ArchType="diff" ]
		then
			#Временное имя файла журнала диференциального архива
			TempArchDiffName=$ArchPath$ArchTemplate"-tempdiff"
			#Если такой файл существует то ошибка локальная и глобальная
			if [ -a $TempArchDiffName ]
			then
				flagOKLocal=false
				flagOKGlobal=false
				printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" Временный журнал поддержки диференциальный копий существует, а временного архива нет\n" >> $BackupLog
			fi
		fi
	fi

	#Если надо делать диференциальный архив то находим копируем последний опортный журнал архива как текущий временный журнал
	if [ $ArchType="diff" ] && [ ! $flagFullNow ] 
	then
		`cp $ArchNameDiffFull $TempArchDiffName`
		if [ -a $TempArchDiffName ]
		then
			printf `(date +%Y-%m-%d-%H-%M-%S)`": Временный файл журнала архива  "$ArchFullName" из источника "$SrcPath" успешно преименован из файла журнала последнего полного архива "$ArchNameDiffFull"\n" >> $BackupLog
		else
			printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА: Копирование журнала архива "$ArchFullName" из источника "$SrcPath" не удалось из файла журнала последнего полного архива "$ArchNameDiffFull"\n" >> $BackupLog
			flagOKGlobal=false
			flagOKLocal=false
		fi
	fi
	
	

	#Если ошибок подготовки архивации этого задания на архивацию не было, то начинаем архивацию
	if [ flagOKLocal ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": Начало создания архива "$ArchFullName" из источника "$SrcPath"\n" >> $BackupLog
		
		#проверяем надо ли использовать режим дифернциальных резервных копий
		if [ $ArchType="diff" ]
		then
			#делаем архив с поддержкой диференциальных копий
			`tar -czpf $TempArchFullName $SrcPath -g $TempArchDiffName 2>> $BackupLog`
		else
			#делаем архив без поддержки диференциальных копий
			`tar -czpf $TempArchFullName $SrcPath 2>> $BackupLog`
		fi
		

		#Проверяем удачно ли произошло архивирование
		if [ $? -eq 0 ];
		then
			printf `(date +%Y-%m-%d-%H-%M-%S)`": Архив "$ArchFullName" успешно создан \n" >> $BackupLog

			if [ -a $ArchFullName ]; 
			then
				printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" Архив с таким именем уже существует - невозможно переименовать временный файл архива \n" >> $BackupLog
				flagOKGlobal=false	
			else
				#переименовываем временный файл архива
				`mv $TempArchFullName $ArchFullName`
				#Если переименовать не получилось то ошибка
				if [ -a $ArchFullName ];
				then
					printf `(date +%Y-%m-%d-%H-%M-%S)`": Временный файл архива "$ArchFullName" из источника "$SrcPath" успешно преименован\n" >> $BackupLog
				else
					printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" из источника "$SrcPath" не удалось переименовать временный файл архива \n" >> $BackupLog
					flagOKGlobal=false
				fi

				#Если в этом архиве включена поддержка диференциальных копий то надо обработать журналы
				if [ $ArchType="diff" ] 
				then
					if [ $flagFullNow ]
					then
						#Если это полный архив, то сохраняем временный журнал архива с поддержкой диференциальных копий, как журнал последнего полного архива 
						#перед этим удаляем все файлы с расширение diff для этого шаблона архива
						`rm -f $ArchPath$ArchTemplate*.diff 2>> $BackupLog`

						if [ -a $ArchNameDiffFull ]
						then
							printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" из источника "$SrcPath". Имя файла для нового журнала последнего полного архива занято "$ArchNameDiffFull" \n" >> $BackupLog
							flagOKGlobal=false
						else
							`mv $TempArchDiffName $ArchNameDiffFull`
							if [ -a $ArchNameDiffFull ]
							then
								printf `(date +%Y-%m-%d-%H-%M-%S)`": Успешно создан файл "$ArchNameDiffFull" для нового журнала последнего полного архива с именем: "$ArchFullName" из источника "$SrcPath"\n" >> $BackupLog
							else
								printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" из источника "$SrcPath". Успешно создан файл для нового журнала последнего полного архива "$ArchNameDiffFull" \n" >> $BackupLog
								flagOKGlobal=false
							fi
						fi
					else
						#Если это дифиренциальный архив, удаляем временный журнал архива с поддержкой диференциальных копий
						`rm -f $TempArchDiffName 2>> $BackupLog`
						if [ -a $TempArchDiffName ]
						then
							printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" из источника "$SrcPath". Не удалось удалить временный файл журнала поддержки диференциальных копий "$TempArchDiffName"\n" >> $BackupLog
							flagOKGlobal=false
						else
							printf `(date +%Y-%m-%d-%H-%M-%S)`": Успешно удален временный файл журнала поддержки диференциальных копий "$TempArchDiffName" для архива с именем: "$ArchFullName" из источника "$SrcPath"\n" >> $BackupLog	
						fi
					fi
				fi
			fi

			#Запускаем функцию удаления ненужных архивов (ротация архивов)
			funArhRotation

		else
			printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с именем: "$ArchFullName" из источника "$SrcPath" Процесс создания архива прошел с ошибками \n" >> $BackupLog
			flagOKGlobal=false
			#Создаем имя для файла неудавшегося архива 
			###?

			#Если файл с именем файла неудавшегося архива существует то удаляем его
			###?

			#Переименовываем временный файл неудавшего архива
			###?

			#Создаем имя для файла журнала архива с поддержкой диференциальных копий
			###?

			#Если файл с именем файла журнала неудавшегося архива с поддержкой диференциальных копий существует то удаляем его
			###?

			#Eсли существует файл с именем временного журнала архива с поддержкой диференциальных копий то переименовываем его
			###?

		fi 
	fi
}


##############################
###  ТОЧКА СТАРТА СКРИПТА  ###

#Флаг  нормального завершения всей процедуры резервного копирования
flagOKGlobal=true

#Определяем путь запуска скрипта
# current path resolver from http://stackoverflow.com/a/246128
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
INSTALL_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
SCRIPT_NAME=$INSTALL_DIR"/"$(basename "$SOURCE")

#Задаем рассположение логфайлов
BackupLog="/var/log/FileBackup.log"
ErrorLog="/var/log/FileBackupERROR.log"
FileWorkCFG=$INSTALL_DIR"/work.cfg"

#Если нет файла work.cfg то производим установку
if [ -a $FileWorkCFG ]
then
	echo "Запускаем скрипт в рабочем режиме"
else
	#Пишем всякое для пользователя-установщика
	echo "Призводим установку скрипта "$SCRIPT_NAME


	#Создаем файл work.cfg
	echo "Создаем файл work.cfg"

	echo "# В данном списке по каждому источнику архивации заполняется следующие строки:" > $FileWorkCFG
	echo "#	1) путь к папке источника	архивации (что архивируем)" >> $FileWorkCFG
	echo "#	2) путь к папке куда будем складывать архивы" >> $FileWorkCFG
	echo "#	3) шаблон имени архива. К шаблогу будет добавлен суфикс типа (Daily, Weekly, Monthly) архива и дата арихива для получения имени архива" >> $FileWorkCFG
	echo "#	4) full или diff - если full, то делаем все архивы будут полными; если diff, то ежедневные архивы всегда диференциальные относительно последнего полного архива " >> $FileWorkCFG 		
	echo "#	5) сторка дополнительных параметров с разделителем |" >> $FileWorkCFG
	echo "#		a) количество ежедневных копий" >> $FileWorkCFG
	echo "#		c) количество еженедельных копий (необязательный параметр)" >> $FileWorkCFG
	echo "#		d) количество ежемесячных копий (необязательный параметр)" >> $FileWorkCFG
	echo "#" >> $FileWorkCFG
	echo "# Пример:" >> $FileWorkCFG
	echo "# /var/lib/plexmediaserver" >> $FileWorkCFG
	echo "# /mnt/BackUp/Plex/" >> $FileWorkCFG
	echo "# plexSettings" >> $FileWorkCFG
	echo "# full" >> $FileWorkCFG
	echo "# 40" >> $FileWorkCFG
	echo "#" >> $FileWorkCFG
	echo "# /usr/plex" >> $FileWorkCFG
	echo "# /mnt/Bаckup/Plex/" >> $FileWorkCFG
	echo "# plexProg" >> $FileWorkCFG
	echo "# full" >> $FileWorkCFG
	echo "# 4|4|6" >> $FileWorkCFG
	echo "#" >> $FileWorkCFG
	echo "# /home/user/temp" >> $FileWorkCFG
	echo "# /mnt/Backup/НomeUserTemp/" >> $FileWorkCFG
	echo "# HomeUserTemp" >> $FileWorkCFG
	echo "# diff" >> $FileWorkCFG
	echo "# 3" >> $FileWorkCFG
	echo "#" >> $FileWorkCFG
	echo "# Первое задание архивации" >> $FileWorkCFG

	#Устанавливаем права на файл work.cfg
	if [ -a $FileWorkCFG ]
	then
		`chmod 660 $FileWorkCFG`
		if [ $? -ne 0 ];
		then 
			echo "Не удается задать права на логфайл "$FileWorkCFG
			flagOKGlobal=false
		fi
	else
		echo "Не удается создать файл "$FileWorkCFG
		flagOKGlobal=false
	fi

	#Устанавливаем права на себя
	if [ -a $SCRIPT_NAME ]
	then
		`chmod 760 $SCRIPT_NAME`
		if [ $? -ne 0 ];
		then 
			echo "Не удается задать права на логфайл "$SCRIPT_NAME
			flagOKGlobal=false
		fi
	else
		echo "Нет доступа к самому себе - "$SCRIPT_NAME
		flagOKGlobal=false
	fi

	#Пишем всякое для пользователя-установщика
	if [ flagOKGlobal ]; 
	then
		echo "Для установки скрипта в cron запустите crontab -e и добавтье следующую строку для выполнения каждый день в 23.30"
		echo "30 23 * * * "$INSTALL_DIR"/FileBackup"
		echo "Задания на архивирование задайте в файле work.cfg"
	else
		echo "Во время установки скрипта возникли ошибки!!!"
	fi
fi

if [ ! -w $BackupLog ]
then
	`cat</dev/null>$BackupLog`
	if [ -a $BackupLog ] 
	then
		echo "Файл "$BackupLog" успешно создан"

		# Задаем права на чтение и редактирование для всех (664) на логфайл сессии резервного копирования
		`chmod 664 $BackupLog`
		if [ $? -ne 0 ];
		then 
			echo "Не удается задать права на логфайл "$BackupLog
			flagOKGlobal=false
		fi
	else
		echo "Не получается создать файл с именем "$BackupLog
		flagOKGlobal=false
	fi
fi

if [ ! -w $ErrorLog ]
then
	#Создание файла лога сессии резервного копирования 
	`cat</dev/null>$ErrorLog`
	if [ -a $ErrorLog ]; 
	then
		echo "Файл "$ErrorLog" успешно создан"
		# Задаем права на чтение и редактирование для всех (664) на логфайл ошибок сессии резервного копирования
		`chmod 664 $ErrorLog`
		if [ $? -ne 0 ];
		then 
			echo "Не удается задать права на логфайл "$ErrorLog
			flagOKGlobal=false
		fi
	else
		echo "Не получается создать файл с именем "$ErrorLog
		flagOKGlobal=false
	fi
fi



#Очищаем старый лог файл если он есть
cat /dev/null > $BackupLog
if [ $? -eq 0 ];
then 
	printf `(date +%Y-%m-%d-%H-%M-%S)`": Файл лога предыдущей сессии успешно удален \n" >> $BackupLog
else
	echo "Не возможно очистить лог сессии выполнения задания резервного копирования - задание остановленно !!!"
	flagOKGlobal=false
fi


if ( $flagOKGlobal );
then
	#Флаг для того чтобы в одном цикле считывать поочереди каждую строку для каждого источника архивирования
	SrcListStringIterator="0"
	
	#Очищаем файл с входными значениями заданий архитвации от комментариев и пропусков строк
	PurifiedListParam=`sed '/^\s*#/d;/^$/d;' $INSTALL_DIR/work.cfg`

	for NextListElement in $PurifiedListParam
	do
		case $SrcListStringIterator in
			"1"|"0" )
			SrcPath=$NextListElement
			SrcListStringIterator="2"
				;;

			"2" )
			ArchPath=$NextListElement
			SrcListStringIterator="3"
				;;

			"3" )
			ArchTemplate=$NextListElement
			SrcListStringIterator="4"
				;;

			"4" )
			ArchType=$NextListElement
			if [[ $ArchType="full" || $ArchType="diff" ]]
			then
				flagOKGlobal=false
				printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА чтения параметра типа архива "$SrcPath" из файла конфигурации - допустимо только одини из 2 видов параметров (full или diff) \n" >> $BackupLog
			fi



			SrcListStringIterator="5"
				;;

			"5" )
			ExtParams=$NextListElement
			SrcListStringIterator="1"

			#Разбираем строку дополнительных параетров
			ArhNumDaily=0
			ArhNumWeekly=0
			ArhNumMonthly=0
			ArhSufix=""
			ExtParamsStringIterator="0"

			
			IFS=$'|'; for NextParam in $ExtParams; 
			do
			 	case $ExtParamsStringIterator in
			 		"1"|"0" )
					ExtParamsStringIterator="2"
					ArhNumDaily=$NextParam
			 			;;
			 		"2" )
					ExtParamsStringIterator="3"
					ArhNumWeekly=$NextParam
			 			;;
			 		"3" )
					ArhNumMonthly=$NextParam
			 			;;	
			 	esac
			done 

			#Запускаем функцию создания архива для текущего задания архивации
			funArhCreation
				;;	
		esac
	done

	#Если все процессы архивирования прошли успешно, то очищаем лог ошибок. Если нет то отправляем лог текушей сессии с сообщением о ошибке по электронной почте 
	#и добавляем содержимое текущего лога в лог о ошибках
	if ( $flagOKGlobal );
	then
		echo "ВСЕ ЗАДАНИЯ АРХИВИРОВАНИЯ ВЫПОЛНЕННЫ УСПЕШНО. Подробности выполнения смотрте в логе "$BackupLog
		printf "\n" >> $BackupLog
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ВСЕ ЗАДАНИЯ АРХИВИРОВАНИЯ ВЫПОЛНЕННЫ УСПЕШНО" >> $BackupLog
		cat /dev/null > $ErrorLog
		###? сообщаем о успешном выполнении резервного копирования

		###? пишем в флаг файл дату и время последнего успешного завершения резервного копирования

	else
		echo "ПРИ ВЫПОЛНЕНИИ ЗАДАНИЙ АРХИВИРОВАНИЯ БЫЛИ ОБНАРУЖЕНЫ ОШИБКИ. Подробности выполнения смотрте в логе "$ErrorLog
		printf "\n" >> $BackupLog
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ЗАДАНИЯ АРХИВИРОВАНИЯ ВЫПОЛНЕННЫ С ОШИБКАМИ !!! \n" >> $BackupLog
		printf "____________________________________________\n" >> $ErrorLog
		cat $BackupLog >> $ErrorLog
		###? отправляем $BackupLog с сообщением о ошибке

	fi
fi	