#!/bin/bash

#SrcList - список заданий архивирования
#В данном списке по каждому источнику архивации заполняется следующие строки:
#	1) путь к папке источника архивации (что архивируем)
#	2) путь к папке куда будем складывать архивы
#	2) шаблон имени архива. К шаблогу будет добавлен суфикс типа (Daily, Weekly, Monthly) архива и дата арихива для получения имени архива
#			
#	3) путь к скрипту дополнительной обработки архива, который исполнится в случае удачного создания архива
#	   если ни чего обрабатывать не надо то пишем "no"
#	   В скрипт можно передать следующие параметры:
#		$SrcPath - путь источника удачно выполненного архива
#		$ArchTemplate - шаблон имени архива	
#		$ArchPath - путь к удачно выполненному архиву
#	4) сторка дополнительных параметров с разделителем |
#		a) количество ежедневных копий
#		c) количество еженедельных копий (необязательный параметр)
#		d) количество ежемесячных копий (необязательный параметр)
#
#Пример:
# SrcList="/var/lib/plexmediaserver
# /mnt/BackUp/Plex/
# plexSettings
#
# 40
# /usr/plex
# /mnt/Bаckup/Plex/
# plexProg
#
# 4|4|6
# /home/user/temp
# /mnt/Backup/НomeUserTemp/
# HomeUserTemp
# /home/user/DelAllFIles $SrcPath
# 3"

SrcList="/var/log
/Volumes/CuraDisk/test
mytest
no
3|2|2
/var/log
/Volumes/CuraDisk/test
mytest
no
3|2|2"

#Файл лога архивации последней сессии
BackupLog="/var/log/FileBackup.log"
ErrorLog="/var/log/FileBackupERROR.log"

#Почтовый адрес куда слать логи с неудачными попытками резервного копирования
EmailAddress="andrey@mibra.ru"

#Функция ротации архивов (уделение устаревших архивов)
funArhRotation ()
{
	#Удаление старых ежемесячных архивов
	let "TailArg = ArhNumMonthly + 1"
	#ls -t $ArchPath$ArchTemplate"-monthly"* -print 2>/dev/null | tail -n +`expr $ArhNumMonthly + 1`
	for NextOldMonthly in `ls -t $ArchPath$ArchTemplate"-monthly"* -print 2>/dev/null | tail -n +$TailArg`; 
	do
		if [ $NextOldMonthly != $ArchFullName ]; 
		then
echo "Удаляем "$NextOldMonthly
			#Удаляем текущий архив
			#???

			#Если удаление прошло неудачно, то ошибка 
			#???

			#Если удаление прошло удачно, то пишем в лог о удачном удалении старого архива
			#???
		fi
	done
}

#Функция обработки каждого задания на архивацию
funArhCreation ()
{

echo "funArh"
	#Флаг успешности выполнения каждого задания на архивацию
	flagOKLocal=true

	#Если последним символом каталога назначения не является "/" то добавляем его
	if [ ${ArchPath:(-1):1} != "/" ]; 
	then
		ArchPath=$ArchPath"/"
	fi

	#Если источник недоступен для чтения, то ошибка создания архива
	if [  ! -r $SrcPath ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" Источник "$SrcPath" не доступен для чтения \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	fi

	#Если каталог назначения недоступен для записи, то ошибка содания архива
	if [  ! -w $ArchPath ] | [  ! -d $ArchPath ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" Каталог "$ArchPath" не доступен для записи или не явлется каталогом \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	fi

	#Формируем имя архива
	printf "\n" >> $BackupLog

	#Ищем имя самого последнего ежемесячного архива 
	OldEndMonthlyArh=`ls -t $ArchPath$ArchTemplate"-monthly"* -print 2>/dev/null | head -1`
			
	#Проверяем а есть ли вообще последний ежемесячный архив
	if [ $OldEndMonthlyArh ]; 
	then
		#Если у нового архива месяц новый и ArhNumMonthly>0 то суфикс имени архива будет monthly
		if [ ${OldEndMonthlyArh:(-24):2} != `date +%m` ] && [ $ArhNumMonthly -gt 0 ]; 
		then
			ArhSufix="monthly"
		fi
	fi

	#Ищем имя самого последнего еженедельного архива
	OldEndWeeklyArh=`ls -t $ArchPath$ArchTemplate"-weekly"* -print 2>/dev/null | head -1`

	#Проверяем а есть ли вообще последний ежемесячный архив
	if [ $OldEndWeeklyArh ]; 
	then
		#Если неделя изменилась, а ArсhSufix="" и ArсhNumWeekly>0 то суфикс имени архива будет weekly 
		if [ ${OldEndWeeklyArh:(-18):2} != `date +%U` ] && [ $ArhNumWeekly -gt 0 ] && [ ! $ArhSufix ]; 
		then
			ArhSufix="weekly"
		fi
	fi

	#Если ArсhSufix="" и ArсhNumDaily>0 то суфикс имени архива будет daily
	if [ $ArhNumDaily -gt 0 ] && [ ! $ArhSufix ]; 
	then
		ArhSufix="daily"
	fi

	#Если суфикс архива не определен то ошибка задачи параметров архива
	if [ ! $ArhSufix ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" Не задано ненулевое количество архивов \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	else
		#Иначе генерируем имя нового архива и запускаем архивацию
		ArchFullName=$ArchPath$ArchTemplate"-"$ArhSufix"-"`(date +%Y-%m-%d-%U-%H_%M_%S)`".tar.gz"
	fi



	#Если файл с таким именем архива существует - то ошибка архива
	if [ -a $ArchFullName ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" Архив с таким именем уже существует - архив не создан \n" >> $BackupLog
		flagOKGlobal=false
		flagOKLocal=false
	fi
	


	#Если ошибок подготовки архивации этого задания на архивацию не було, то начинаем архивацию
	if [ flagOKLocal ]; 
	then
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" из источника "$SrcPath" \n" >> $BackupLog
echo "Архивируем"
		#tar -cvzpf $ArchFullName $SrcPath >> $BackupLog

		#Проверяем удачно ли произошло архивирование
		if [ $? -eq 0 ];
		then
			printf `(date +%Y-%m-%d-%H-%M-%S)`": Архив "$ArchPath$ArchTemplate" успешно создан \n" >> $BackupLog

			#Запускаем функцию удаления ненужных архивов (ротация архивов)
			funArhRotation

			#Выполняем внешний скрипт, если это необходимо
			#???

		else
			printf `(date +%Y-%m-%d-%H-%M-%S)`": ОШИБКА СОЗДАНИЯ АРХИВА с шаблоном имени: "$ArchPath$ArchTemplate" Процесс создания архива прошел с ошибками \n" >> $BackupLog
			flagOKGlobal=false
		fi 
	fi
}





#Удаляем временный лог файл если они есть 
if [ -e "$BackupLogPath" ]; then rm $BackupLogPath ; fi

#Флаг  нормального завершения всей процедуры резервного копирования
flagOKGlobal=true

#Очищаем старый лог файл если он есть
cat /dev/null > $BackupLog
if [ $? -eq 0 ];
then 
	printf `(date +%Y-%m-%d-%H-%M-%S)`": Файл лога предыдущей сессии успешно удален \n" >> $BackupLog
else
	echo "Не возможно очистить лог сессии выполнения задания резервного копирования - задание остановленно !!!"
	flagOKGlobal=false
fi


if ( $flagOKGlobal );
then
	#Флаг для того чтобы в одном цикле считывать поочереди каждую строку для каждого источника архивирования
	SrcListStringIterator="0"
	#Цикл перебора строк параметров
	IFS=$'\n'; for NextListElement in $SrcList;
	do
		case $SrcListStringIterator in
			"1"|"0" )
			SrcPath=$NextListElement
			SrcListStringIterator="2"
				;;

			"2" )
			ArchPath=$NextListElement
			SrcListStringIterator="3"
				;;

			"3" )
			ArchTemplate=$NextListElement
			SrcListStringIterator="4"
				;;

			"4" )
			ScriptParh=$NextListElement
			SrcListStringIterator="5"
				;;	

			"5" )
			ExtParams=$NextListElement
			SrcListStringIterator="1"

			#Разбираем строку дополнительных параетров
			ArhNumDaily=0
			ArhNumWeekly=0
			ArhNumMonthly=0
			ArhSufix=""
			ExtParamsStringIterator="0"

			
			IFS=$'|'; for NextParam in $ExtParams; 
			do
			 	case $ExtParamsStringIterator in
			 		"1"|"0" )
					ExtParamsStringIterator="2"
					ArhNumDaily=$NextParam
			 			;;
			 		"2" )
					ExtParamsStringIterator="3"
					ArhNumWeekly=$NextParam
			 			;;
			 		"3" )
					ArhNumMonthly=$NextParam
			 			;;	
			 	esac
			done 

			#Запускаем функцию создания архива для текущего задания архивации
			funArhCreation			

			echo "Источник" $SrcPath " получатель " $ArchPath " скрипт " $ScriptParh "ArhNumDaily="$ArhNumDaily "ArhNumWeekly="$ArhNumWeekly "ArhNumMonthly="$ArhNumMonthly
				;;	
		esac
	done

	#Если все процессы архивирования прошли успешно, то очищаем лог ошибок. Если нет то отправляем лог текушей сессии с сообщением о ошибке по электронной почте 
	#и добавляем содержимое текущего лога в лог о ошибках
	if ( $flagOKGlobal );
	then
		printf "\n" >> $BackupLog
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ВСЕ ЗАДАНИЯ АРХИВИРОВАНИЯ ВЫПОЛНЕННЫ УСПЕШНО" >> $BackupLog
		cat /dev/null > $ErrorLog
	else
		printf "\n" >> $BackupLog
		printf `(date +%Y-%m-%d-%H-%M-%S)`": ЗАДАНИЯ АРХИВИРОВАНИЯ ВЫПОЛНЕННЫ С ОШИБКАМИ !!! \n" >> $BackupLog
		printf "____________________________________________\n" >> $ErrorLog
		cat $BackupLog > $ErrorLog
		#отправляем $BackupLog по электронной почте с сообщение о ошибке
		#???
	fi
fi	